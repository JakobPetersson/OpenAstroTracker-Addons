# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import glob
import win32file
import re
import time
from datetime import datetime
import win32com.client, pywintypes
import argparse
import json
import math
from PyQt5 import QtCore, QtGui, QtWidgets
import sys, os
from collections import OrderedDict
import logging

class QTextEditLogger(logging.Handler):
    def __init__(self, parent):
        super().__init__()
        self.widget = QtWidgets.QPlainTextEdit(parent)
        self.widget.setReadOnly(True)

    def emit(self, record):
        msg = self.format(record)
        self.widget.appendPlainText(msg)
        
class AutoPA(QtWidgets.QDialog, QtWidgets.QPlainTextEdit):
    def setupUi(self, Dialog):
        Dialog.setObjectName("AutoPA")
        Dialog.resize(400, 300)
        self.formLayout = QtWidgets.QFormLayout(Dialog)
        self.formLayout.setObjectName("formLayout")
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setObjectName("label")
        self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.label)
        self.software = QtWidgets.QComboBox(Dialog)
        self.software.setCurrentText("")
        self.software.setObjectName("software")
        self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.software)
        self.label_4 = QtWidgets.QLabel(Dialog)
        self.label_4.setObjectName("label_4")
        self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.label_4)
        self.accuracy_input = QtWidgets.QLineEdit(Dialog)
        self.accuracy_input.setObjectName("accuracy")
        self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.accuracy_input)
        self.label_2 = QtWidgets.QLabel(Dialog)
        self.label_2.setObjectName("label_2")
        self.formLayout.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.label_2)
        self.azimuthOffset = QtWidgets.QLineEdit(Dialog)
        self.azimuthOffset.setObjectName("azimuthOffset")
        self.formLayout.setWidget(2, QtWidgets.QFormLayout.FieldRole, self.azimuthOffset)
        self.label_3 = QtWidgets.QLabel(Dialog)
        self.label_3.setObjectName("label_3")
        self.formLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.label_3)
        self.altitudeOffset = QtWidgets.QLineEdit(Dialog)
        self.altitudeOffset.setObjectName("altitudeOffset")
        self.formLayout.setWidget(3, QtWidgets.QFormLayout.FieldRole, self.altitudeOffset)
        self.verbose = QtWidgets.QCheckBox(Dialog)
        self.verbose.setObjectName("verbose")
        self.formLayout.setWidget(5, QtWidgets.QFormLayout.LabelRole, self.verbose)

        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.startButton = QtWidgets.QPushButton(Dialog)
        self.startButton.setAutoRepeat(True)
        self.startButton.setAutoRepeatInterval(5000)
        self.startButton.setObjectName("startButton")
        self.startButton.clicked.connect(self.start)
        self.horizontalLayout.addWidget(self.startButton)
        self.stopButton = QtWidgets.QPushButton(Dialog)
        self.stopButton.setObjectName("stopButton")
        self.stopButton.clicked.connect(self.stop)
        self.horizontalLayout.addWidget(self.stopButton)
        self.cancelButton = QtWidgets.QPushButton(Dialog)
        self.cancelButton.setObjectName("cancelButton")
        self.cancelButton.clicked.connect(self.close)
        self.horizontalLayout.addWidget(self.cancelButton)
        self.formLayout.setLayout(5, QtWidgets.QFormLayout.FieldRole, self.horizontalLayout)
        
        logTextBox = QTextEditLogger(self)
        logTextBox.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logging.getLogger().addHandler(logTextBox)
        logging.getLogger().setLevel(logging.INFO)
        self.formLayout.setWidget(10, QtWidgets.QFormLayout.SpanningRole, logTextBox.widget)

        self.timer=QtCore.QTimer()
        self.timer.timeout.connect(self.alignment)

        self.lastEntry = None
        self.aligned = True
        self.stillAdjusting = False
        self.adjustmentFinished = datetime.now()
        self.after_id = None
        
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "AutoPA"))
        self.label.setText(_translate("Dialog", "Choose your AutoPA software:"))
        self.software.addItems(software_options.keys())
        self.label_4.setText(_translate("Dialog", "Accuracy to align to (Default 60 arcseconds):"))
        self.accuracy_input.setText(_translate("Dialog", "60"))
        self.accuracy_input.setPlaceholderText(_translate("Dialog", "60"))
        self.label_2.setText(_translate("Dialog", "+/- Azimuth Offset (Default 0 arcminutes):"))
        self.azimuthOffset.setText(_translate("Dialog", "0"))
        self.azimuthOffset.setPlaceholderText(_translate("Dialog", "0"))
        self.label_3.setText(_translate("Dialog", "+/- Altitude Offset (Default 0 arcminutes):"))
        self.altitudeOffset.setText(_translate("Dialog", "0"))
        self.altitudeOffset.setPlaceholderText(_translate("Dialog", "0"))
        self.verbose.setText(_translate("Dialog", "Verbose Output"))
        self.startButton.setText(_translate("Dialog", "Start"))
        self.stopButton.setText(_translate("Dialog", "Stop"))
        self.cancelButton.setText(_translate("Dialog", "Close"))

    def getLatestLogEntry(self, logpath, expression):
        try:
            list_of_files = glob.glob(logpath)
            latest_file = max(list_of_files, key=os.path.getctime)
            logging.debug(latest_file)
            f = win32file.CreateFile(latest_file, win32file.GENERIC_READ, win32file.FILE_SHARE_DELETE | win32file.FILE_SHARE_READ | win32file.FILE_SHARE_WRITE, None, win32file.OPEN_EXISTING, win32file.FILE_ATTRIBUTE_NORMAL, None)
            bufSize = 4096
            code, data = win32file.ReadFile(f, bufSize)
            buf = data
            while len(data) == bufSize:
                result, data = win32file.ReadFile(f, bufSize, None)
                buf += data
            result = re.findall(expression, buf.decode("utf-8"))[-1]
            return(result)
        except:
            raise FileNotFoundError
        
    def altitudeError(self, error, pole):
        return(self.dmsTodeg(pole)-self.dmsTodeg(error))

    def azimuthError(self, error, pole):
        return(((self.dmsTodeg(pole) + 180) % 360 - 180)-((self.dmsTodeg(error) + 180) % 360 - 180))

    def dmsTodeg(self, input):
        temp = input.split(':')
        d = float(temp[0])
        m = float(temp[1]) / 60
        s = float(temp[2]) / 3600
        return (d + m + s)

    def degToArcmin(self, input):
        return(input * 60)

    def parseError(self, software, input, azimuthOffset, altitudeOffset):
        error = []
        if software == "NINA":
            data = json.loads(input[1])
            error.append((self.degToArcmin(data["AltitudeError"]) - altitudeOffset)*(-1))
            error.append((self.degToArcmin(data["AzimuthError"]) - azimuthOffset)*(-1))
            error.append(self.degToArcmin(data["TotalError"]))
        elif software == "Sharpcap3.2" or software == "Sharpcap4.0":
            error.append(self.degToArcmin(self.altitudeError(input[1], input[3])) - altitudeOffset)
            error.append(self.degToArcmin(self.azimuthError(input[2], input[4])) - azimuthOffset)
            error.append(math.hypot(error[0], error[1]))    
        return(error)
        
    def sendCommand(self, command):
        logging.debug(command)
        tel = win32com.client.Dispatch("ASCOM.OpenAstroTracker.Telescope")
        if tel.Connected:
            logging.debug("Telescope was already connected")
        else:
            tel.Connected = True
            if not tel.Connected:
                logging.error("Unable to connect to telescope.")
                return False
        result = tel.Action("Serial:PassThroughCommand", command)
        tel.Connected = False
        return result

    def isAdjusting(self):
        try:
            result = self.sendCommand(":GX#,#")
            if not result:
                raise ConnectionError
            logging.debug(result)
            status = re.search(",(......),", result)[1]
            if status[3]=="-" and status[4]=="-":
                return False
            else:
                return True
        except:
            logging.error("Problem determining mount status. Verify ASCOM/mount is connected. Stopping AutoPA.")
            self.timer.stop()
            raise ConnectionError

    def start(self):
        if self.verbose.isChecked():
            logging.getLogger().setLevel(logging.DEBUG)
        else:
            logging.getLogger().setLevel(logging.INFO)
        if self.aligned:
            logging.info("Starting AutoPA routine")
            self.aligned = False
            self.accuracy = float(self.accuracy_input.text()) / 60
            self.timer.start(1000)        
        
    def stop(self):
        self.aligned = True
        self.timer.stop()
        
    def close(self):
        sys.exit(self)
           
    def alignment(self):
        if not self.aligned:
            try:
                if self.isAdjusting():
                    logging.info("Mount is still adjusting position.")
                    self.stillAdjusting = True
                else:
                    if self.stillAdjusting:
                        logging.info(f"Mount adjustment finished.")
                        self.stillAdjusting = False
                        self.adjustmentFinished = datetime.now()
                    logging.info(f"Getting latest log entry from {self.software.currentText()}.")
                    try:
                        log = self.getLatestLogEntry(softwareTypes[self.software.currentText()]["logpath"], softwareTypes[self.software.currentText()]["expression"])
                    except FileNotFoundError:
                        log = None
                        logging.error(f"Error retrieving log from {self.software.currentText()}.")
                    if log is not None:
                        currentEntry = datetime.strptime(datetime.today().strftime("%Y-%m-%d") + " " + log[0][:-1], '%Y-%m-%d %H:%M:%S.%f') #get last log entry (assume todays date)
                        if currentEntry != self.lastEntry and currentEntry > self.adjustmentFinished:   #Only adjust based on the latest unused entry, and only if it was entered into the log after the adjustment was finished.
                            error = self.parseError(self.software.currentText(), log, float(self.azimuthOffset.text()), float(self.altitudeOffset.text()))
                            logging.info(f"Altitude error in arcminutes: {error[0]:.3f}\'")
                            logging.info(f"Azimuth error in arcminutes: {error[1]:.3f}\'")
                            logging.info(f"Total error in arcminutes: {error[2]:.3f}\'")
                            if abs(error[2]) < self.accuracy:
                                self.aligned = True
                            else:
                                logging.info("Correction needed.")
                                result = self.sendCommand(f":MAL{error[0]}#")
                                logging.debug(f"Adjusting altitude by {error[0]:.3f} arcminutes.")
                                result = self.sendCommand(f":MAZ{error[1]*(-1)}#")
                                logging.debug(f"Adjusting altitude by {error[0]:.3f} arcminutes.")
                                self.lastEntry = currentEntry
                        else:
                            logging.info(f"Waiting for {self.software.currentText()} to re-solve since last adjustment finished.")
                    else:
                        logging.info(f"{self.software.currentText()} has not yet determined the polar alignment error.")
            except ConnectionError:
                self.aligned = True
                return
        else:
            logging.info(f"Polar aligned to within {error[0]*60:.0f}\" altitude and {error[1]*60:.0f}\" azimuth.")
           

software_options = OrderedDict([
    ('NINA', ''),
    ('Sharpcap4.0', ''),
    ('Sharpcap3.2', ''),
    ])

softwareTypes = {
"NINA":{        "expression": "(\d{2}:\d{2}:\d{2}.\d{3})\s-\s({.*})", 
                "logpath": f"{os.getenv('USERPROFILE')}\Documents\\N.I.N.A\PolarAlignment\*.log"},
"Sharpcap3.2":{ "expression": "(?:Info:)\t(\d{2}:\d{2}:\d{2}.\d{7}).*(?:AltAzCor=)(?:Alt=)(.*)[,](?:Az=)(.*).\s(?:AltAzPole=)(?:Alt=)(.*)[,](?:Az=)(.*).[,]\s(?:AltAzOffset=).*", 
                "logpath": f"{os.getenv('LOCALAPPDATA')}\SharpCap\logs\*.log"},
"Sharpcap4.0":{ "expression": "(?:Info)\W*(\d{2}:\d{2}:\d{2}.\d{6}).*(?:AltAzCor=)(?:Alt=)(.*)[,](?:Az=)(.*).\s(?:AltAzPole=)(?:Alt=)(.*)[,](?:Az=)(.*).[,]\s(?:AltAzOffset=).*", 
                "logpath": f"{os.getenv('LOCALAPPDATA')}\SharpCap\logs\*.log"}
}            
        
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = QtWidgets.QDialog()
    ui = AutoPA()
    ui.setupUi(window)

    window.show()
    sys.exit(app.exec_())
